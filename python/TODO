
Idea for new module structure: refactor 'fatcat_client' into 'fatcat' and have
that be the general purpose API client. create a new 'fatcat_services' for web
interface, importers, workers, etc, which depends on the other module.
potentially, move library module into subdirectory or another top-level folder
("python-fatcat"? "python-library"?).

- use dict counter type (in python collections) instead of currently janky counters
- schema.org metadata for releases

additional tests
- full object fields actually getting passed e2e (for rich_app)
- implicit editor.active_edit_group behavior
- modify existing release via edit mechanism (and commit)
- redirect a release to another (merge)
- update (via edit) a redirect release
- api: try to reuse an accepted edit group
- api: try to modify an accepted release
- api: multiple edits, same entity, same editgroup

views
- oldest un-merged edits/edit-groups
- changelog more like a https://semantic-ui.com/views/feed.html ?
- instead of grid, maybe https://semantic-ui.com/elements/rail.html

backlog
- make debugbar really optional (don't import unless we're in debug mode)

#![allow(missing_docs)]

extern crate chrono;
extern crate clap;
extern crate diesel;
extern crate dotenv;
extern crate fatcat;
extern crate fatcat_api;
extern crate futures;
extern crate iron;
extern crate iron_slog;
#[macro_use]
extern crate error_chain;
#[macro_use]
extern crate slog;
extern crate slog_async;
extern crate slog_term;

use clap::{App, Arg};
use dotenv::dotenv;
use iron::{Chain, Iron};
use iron_slog::{DefaultLogFormatter, LoggerMiddleware};
use slog::{Drain, Logger};
use std::env;
//use swagger::auth::AllowAllMiddleware;

/// Create custom server, wire it to the autogenerated router,
/// and pass it to the web server.
fn main() {
    let matches = App::new("server")
        .arg(
            Arg::with_name("https")
                .long("https")
                .help("Whether to use HTTPS or not"),
        )
        .get_matches();

    let decorator = slog_term::TermDecorator::new().build();
    let drain = slog_term::CompactFormat::new(decorator).build().fuse();
    let drain = slog_async::Async::new(drain).build().fuse();
    let logger = Logger::root(drain, o!());
    let formatter = DefaultLogFormatter;

    let server = fatcat::server().unwrap();
    let router = fatcat_api::router(server);

    let mut chain = Chain::new(LoggerMiddleware::new(router, logger, formatter));

    // Auth stuff unused for now
    //chain.link_before(fatcat_api::server::ExtractAuthData);
    // add authentication middlewares into the chain here
    // for the purpose of this example, pretend we have authenticated a user
    //chain.link_before(AllowAllMiddleware::new("cosmo"));

    chain.link_after(fatcat::XClacksOverheadMiddleware);

    if matches.is_present("https") {
        unimplemented!()
    } else {
        // Using HTTP
        Iron::new(chain)
            .http("localhost:9411")
            .expect("Failed to start HTTP server");
    }
}
